// this is called s5event because there is also an "event" which is
// important to us--the event that is generated by the DOM objects.
// when imported with the usual notation, clients can use S5Event.Event
// but we can't do that inside this implementation and its brothers.
export default interface s5event {
  Type: string;
  X: number;
  Y: number;
  PickList: pickList | null; // this is not always defined, for example if not positional
  Translate(adjustX: number, adjustY: number): void;
}

export class pickList {
  _hits: pickable[] = [];

  get Hits(): pickable[] {
    return this._hits;
  }

  get Length(): number {
    if (!this._hits) {
      return 0;
    }
    return this._hits.length;
  }

  // returns the first pickable that matches the function provided.
  // iterates in front to back order.
  FindFirst(fn: (i: pickable) => boolean): pickable | null {
    let found: pickable | null = null;
    this._hits.forEach((p: pickable) => {
      if (found === null) {
        if (fn(p)) {
          found = p;
        }
      }
    });
    return found;
  }

  AppendHit(i: pickable): void {
    this._hits.unshift(i);
  }

  /**
   * Returns a list of pickables (probably interactors) that cover the
   * point provided in e.  The list is ordered back to front.  This is
   * a mutating operation.
   * @param e
   * @param rootPickable
   */
  Build(e: s5event, rootPickable: pickable): void {
    rootPickable.Picks(e, this);
  }
}

/**
 * Avoids a lot of hassle with import cycles to just get this single
 * purpose set of 3 methods here...this probably should be
 * "interactor" pretty much everywhere it is used
 */
export interface pickable {
  Picks(e: s5event, pl: pickList): void;
  X: number;
  Y: number;
}
